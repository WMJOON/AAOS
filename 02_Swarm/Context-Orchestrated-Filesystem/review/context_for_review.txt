---
type: "COF-DOCTRINE"
version: "0.1.0"
date: "2026-01-22"
---

# COF Doctrine: The Four Pillars

> **Inheritance Note**: This doctrine inherits and evolves the principles defined in earlier COF versions (â‰¤ v0.1.2). It retains the core definition of "Context-Orchestrated Filesystem" while expanding the philosophical foundation for Agentic AI.

Context-Orchestrated Filesystem (COF)ëŠ” ë‹¨ìˆœí•œ íŒŒì¼ ê·œì¹™ì´ ì•„ë‹ˆë¼, **"AI Agentê°€ ë¬¼ë¦¬ì  ê³µê°„(Filesystem)ì„ ì¸ì§€í•˜ëŠ” ì² í•™"**ì´ë‹¤. ë³¸ ë…íŠ¸ë¦°ì€ COFì˜ ëª¨ë“  ê·œì¹™ê³¼ ìŠ¤í‚¬ì´ ì§€í–¥í•´ì•¼ í•  4ê°€ì§€ ì ˆëŒ€ì  ê¸°ë‘¥(Pillars)ì„ ì •ì˜í•œë‹¤.

## 0. Fundamental Principle (Inherited)

> **"Skill-Mediated Creation Only"**

- **ì›ì¹™**: ì •ì˜ëœ Node(e.g., `task-manager`)ëŠ” ë°˜ë“œì‹œ ìŠ¹ì¸ëœ Skillì„ í†µí•´ì„œë§Œ ìƒì„±ëœë‹¤. ì‚¬ìš©ìì™€ ì—ì´ì „íŠ¸ëŠ” íŒŒì¼/ë””ë ‰í† ë¦¬ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì¡°ì‘í•´ì„œëŠ” ì•ˆ ëœë‹¤.
- **Why**: êµ¬ì¡°ì  ì •í•©ì„±ê³¼ ë©”íƒ€ë°ì´í„°(Rule, Frontmatter) ëˆ„ë½ì„ ë°©ì§€í•˜ê¸° ìœ„í•¨ì´ë‹¤. (v0.1.2 Principle #1, #2 ê³„ìŠ¹)

## 1. Context Locality (ë§¥ë½ì˜ êµ­ì†Œì„±)

> **"ì‘ì—…ì´ ì¼ì–´ë‚˜ëŠ” ê³³ì— ë§¥ë½ì´ ìˆì–´ì•¼ í•œë‹¤."**

- **ì›ì¹™**: ì‘ì—…ì— í•„ìš”í•œ ì •ë³´(Rule, History, Context)ëŠ” ì—ì´ì „íŠ¸ê°€ ì‘ì—…í•˜ëŠ” ë””ë ‰í† ë¦¬(Node)ì˜ `sibling` ë˜ëŠ” `descendant` ë²”ìœ„ ë‚´ì— ë¬¼ë¦¬ì ìœ¼ë¡œ ì¡´ì¬í•´ì•¼ í•œë‹¤.
- **Why**: ì—ì´ì „íŠ¸ëŠ” ì œí•œëœ Context Windowë¥¼ ê°€ì§„ë‹¤. ì¤‘ì•™ì§‘ì¤‘ì‹ ë¬¸ì„œ(Global Wiki)ë¥¼ ë’¤ì§€ëŠ” ê²ƒë³´ë‹¤, ë°œë°‘(Local Node)ì— ìˆëŠ” ì •ë³´ê°€ ê°€ì¥ ê´€ë ¨ì„±ì´ ë†’ê³  ë¹„ìš© íš¨ìœ¨ì ì´ë‹¤.
- **Action**: ëª¨ë“  `task-manager` ë…¸ë“œëŠ” í•´ë‹¹ ì‘ì—… ê³µê°„ ë°”ë¡œ ì˜†(Sibling)ì— ìœ„ì¹˜ì‹œí‚¨ë‹¤.

## 2. Self-Descriptiveness (ìê¸° ì„œìˆ ì„±)

> **"ë§í•˜ì§€ ì•ŠëŠ” ë…¸ë“œëŠ” ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²ƒì´ë‹¤."**

- **ì›ì¹™**: ëª¨ë“  ë…¸ë“œ(ë””ë ‰í† ë¦¬/íŒŒì¼)ëŠ” ìì‹ ì´ ë¬´ì—‡ì´ë©°, ì–´ë–¤ ê·œì¹™ì„ ë”°ë¥´ëŠ”ì§€ ëª…ì‹œì ìœ¼ë¡œ ì„¤ëª…í•´ì•¼ í•œë‹¤.
- **Why**: ì¸ê°„ì€ ì•”ë¬µì  í•©ì˜ë¡œ í´ë”ë¥¼ ì“°ì§€ë§Œ, ì—ì´ì „íŠ¸ëŠ” ëª…ì‹œì  í…ìŠ¤íŠ¸(`README.md`, `RULE.md`) ì—†ì´ëŠ” í´ë”ì˜ ì˜ë„ë¥¼ ì¶”ë¡ í•´ì•¼ í•˜ë¯€ë¡œ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.
- **Action**: í•µì‹¬ ë…¸ë“œì—ëŠ” ë°˜ë“œì‹œ `RULE.md`ë¥¼ ë°°ì¹˜í•˜ì—¬ ì—ì´ì „íŠ¸ì—ê²Œ "ì´ ê³µê°„ì˜ ë²•ì¹™"ì„ ì„ ì–¸í•œë‹¤.

## 3. Agent-First Design (ì—ì´ì „íŠ¸ ìš°ì„  ì„¤ê³„)

> **"ì¸ê°„ì´ ë³´ê¸° ì¢‹ì€ ê²ƒì´ ì•„ë‹ˆë¼, ì—ì´ì „íŠ¸ê°€ ì½ê¸° ì¢‹ì•„ì•¼ í•œë‹¤."**

- **ì›ì¹™**: íŒŒì¼ëª…, êµ¬ì¡°, ë‚´ìš©ì€ Agentì˜ íŒŒì‹±(Parsing)ê³¼ íƒìƒ‰(Traversal) íš¨ìœ¨ì„±ì„ ìµœìš°ì„ ìœ¼ë¡œ ê³ ë ¤í•œë‹¤.
- **Why**: ê¸´ ë¬¸ì¥ë³´ë‹¤ëŠ” êµ¬ì¡°í™”ëœ YAML Frontmatterê°€, ëª¨í˜¸í•œ ì´ë¦„ë³´ë‹¤ëŠ” `YYYYMMDD` ê°™ì€ ì •í˜•í™”ëœ íŒ¨í„´ì´ ì—ì´ì „íŠ¸ì˜ ì‹¤ìˆ˜ë¥¼ ì¤„ì¸ë‹¤.
- **Action**: ëª¨ë“  Ticketê³¼ Noteì— YAML Frontmatterë¥¼ í•„ìˆ˜í™”í•˜ê³ , ëª…í™•í•œ ë„¤ì´ë° ê·œì¹™(Sanitized Filename)ì„ ê°•ì œí•œë‹¤.

## 4. Traceable Lifecycle (ì¶”ì  ê°€ëŠ¥í•œ ìƒëª…ì£¼ê¸°)

> **"ì‹œì‘ê³¼ ëì´ ì—†ëŠ” ë°ì´í„°ëŠ” ì“°ë ˆê¸°ë‹¤."**

- **ì›ì¹™**: ìƒì„±ëœ ê·¼ê±°(Creation Context)ì™€ ì†Œë©¸ ì¡°ê±´(Dissolution Condition)ì´ ì •ì˜ë˜ì§€ ì•Šì€ ì •ë³´ëŠ” ì‹œìŠ¤í…œì— ë‚¨ê¸°ì§€ ì•ŠëŠ”ë‹¤.
- **Why**: ì—ì´ì „íŠ¸ëŠ” ë¬´í•œì • ë°ì´í„°ë¥¼ ìƒì„±í•˜ëŠ” ê²½í–¥ì´ ìˆë‹¤. ì–¸ì œ ì§€ì›Œì•¼ í• ì§€ ëª¨ë¥´ëŠ” ë°ì´í„°ëŠ” ì‹œìŠ¤í…œì„ ì˜¤ì—¼ì‹œí‚¤ê³  ë¯¸ë˜ì˜ ì—ì´ì „íŠ¸ì—ê²Œ í˜¼ë€(Hallucination Trigger)ì„ ì¤€ë‹¤.
- **Action**: `Natural Dissolution` ì›ì¹™ì— ë”°ë¼ ì™„ë£Œëœ ì‘ì—…ì€ ì•„ì¹´ì´ë¹™í•˜ê³ , ë¶ˆí•„ìš”í•œ ë…¸ë“œëŠ” ìŠ¤ìŠ¤ë¡œ ì •ë¦¬í•  ìˆ˜ ìˆë„ë¡ ì„¤ê³„í•œë‹¤.
---
name: "AAOS-COF"
version: "0.1.3"
scope: "04_Agentic_AI_OS/02_Swarm/context-orchestrated-filesystem"
owner: "AAOS Swarm"
created: "2026-01-22"
status: canonical

# Normative References (inherit Immune System)
canon_reference: "04_Agentic_AI_OS/README.md"
meta_doctrine_reference: "04_Agentic_AI_OS/00_METADoctrine/DNA.md"
immune_doctrine_reference: "04_Agentic_AI_OS/01_Nucleus/immune_system/rules/README.md"
inquisitor_reference: "04_Agentic_AI_OS/01_Nucleus/immune_system/SWARM_INQUISITOR_SKILL/"
audit_log_reference: "04_Agentic_AI_OS/01_Nucleus/record_archive/_archive/audit-log/AUDIT_LOG.md"

natural_dissolution:
  purpose: "íŠ¸ë¦¬ ê¸°ë°˜ íŒŒì¼ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì—ì„œ ë…¸ë“œ êµ¬ì¡°/ë§¥ë½/ê¸°ë¡ ê·œì¹™ì„ í‘œì¤€í™”í•˜ì—¬ ì‘ì—… ì—°ì†ì„±ì„ ìœ ì§€í•œë‹¤"
  termination_conditions:
    - "COFê°€ êµ°ì²´(Swarm) í‘œì¤€ì—ì„œ íê¸°/ëŒ€ì²´ë  ë•Œ"
    - "í•´ë‹¹ COF ë²„ì „(v0.1.3)ì´ ìƒìœ„ ë²„ì „ìœ¼ë¡œ ìŠ¹ê³„ë˜ì–´ ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•Šì„ ë•Œ"
  dissolution_steps:
    - "ìƒìœ„ ë²„ì „/ëŒ€ì²´ êµ°ì²´(Swarm)ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ ì‘ì„±"
    - "í•„ìˆ˜ ê·œì¹™/í…œí”Œë¦¿ ìš”ì•½ì„ `README.md`ì— ë‚¨ê¸°ê³  `_archive/`ë¡œ ì•„ì¹´ì´ë¸Œ"
    - "êµ¬ë²„ì „ ìŠ¤í‚¬/ìŠ¤í¬ë¦½íŠ¸ëŠ” `_archive/`ë¡œ ì´ë™ í›„ ì‚­ì œ"
  retention:
    summary_required: true
    max_days: 180

resource_limits:
  max_files: 800
  max_folders: 120
  max_log_kb: 512

inquisitor:
  required: true
  audit_log: "../../01_Nucleus/record_archive/_archive/audit-log/AUDIT_LOG.md"
---

# AAOS-COF DNA (v0.1.3)

ë³¸ DNAëŠ” `COF v0.1.3` êµ°ì²´(Swarm) êµ¬ì¡°ë¥¼ ì •ì˜í•˜ëŠ” í•µì‹¬ ìœ ì „ì²´(Genome)ì´ë‹¤.
META Doctrine(DNA.md) ë° **COF Doctrine**ì— ì˜ê±°í•˜ì—¬ ì‘ì„±ë˜ì—ˆë‹¤.

## 0. Doctrine Genome (ì² í•™ ìœ ì „ì²´)

- **Source**: `core-docs/COF_DOCTRINE.md`
- **Role**:
  - AAOS-COFì˜ 4ëŒ€ ê¸°ë‘¥ ì •ì˜ (Context Locality, Self-Descriptiveness, Agent-First, Traceable Lifecycle)
  - ëª¨ë“  í•˜ìœ„ Genomeì˜ ì„¤ê³„ ì² í•™ ì œê³µ

## 1. Rule Genome (ê·œì¹™ ìœ ì „ì²´)

- **Source**: `RULE.md` (New in v0.1.3)
- **Role**:
  - Skill Usage Mandate (ìŠ¤í‚¬ ì‚¬ìš© ì˜ë¬´í™”)
  - Node Definitions & Workflow Integration

## 2. Skill Genome (í–‰ë™ ìœ ì „ì²´)

- **Source**: `skills/`
- **Active Skills**:
  - `cof-task-context-management`: Task Manager, Ticket ìƒì„±/ê´€ë¦¬, **Auto-Archiving** ì§€ì› (v0.1.3 updated)

## 3. Lifecycle Genome (ìƒëª…ì£¼ê¸° ìœ ì „ì²´)

- **Source**: `DNA.md`
- **Role**:
  - Natural Dissolution (ìì—° ì†Œë©¸) ì¡°ê±´ ì •ì˜
  - **Auto-Enforcement**: ìì› ìƒí•œ ë° ì•„ì¹´ì´ë¹™ ì •ì±… ìë™í™”
  - Inquisitor (ì‹¬íŒê´€) ê°ì‚¬ ë¡œê·¸ ì—°ë™

---

> "ëª¨ë“  COF ì¸ìŠ¤í„´ìŠ¤ëŠ” ë³¸ DNAì™€ COF Doctrineì— ì •ì˜ëœ ì² í•™ì„ êµ¬í˜„í•´ì•¼ í•œë‹¤."
---
trigger: always_on
description: "COFì˜ ëª¨ë“  Node ìƒì„± ë° ê´€ë¦¬ëŠ” ë³¸ ê·œì¹™ì„ ë”°ë¥´ë©°, ì •ì˜ëœ Skillì„ í†µí•´ì„œë§Œ ìˆ˜í–‰ëœë‹¤."
---

# COF v0.1.3 RULE

ë³¸ ê·œì¹™ì€ **Rule Genome**ì— í•´ë‹¹í•˜ë©°, ì—ì´ì „íŠ¸ê°€ COF í™˜ê²½ì—ì„œ í–‰ë™í•˜ëŠ” **ì‹¤í–‰ ì§€ì¹¨(Execution Guidelines)**ì´ë‹¤.

## 1. Skill Usage Mandate (ìŠ¤í‚¬ ì‚¬ìš© ì˜ë¬´)

COF ë…íŠ¸ë¦°ì˜ "Skill-Mediated Creation Only" ì›ì¹™ì— ë”°ë¼, ë‹¤ìŒ ì‘ì—…ì€ ë°˜ë“œì‹œ ì§€ì •ëœ Skillì„ í˜¸ì¶œí•´ì•¼ í•œë‹¤.

| ëª©ì  (Intent) | ëŒ€ìƒ Node | í•„ìˆ˜ Skill | ë¹„ê³  |
|---|---|---|---|
| **ì‘ì—… ë§¥ë½ ìƒì„±/ì´ˆê¸°í™”** | `NN.agents-task-context/` (legacy: `task-manager/`) | `cof-task-context-management` | `create_node.py` ì‹¤í–‰ |
| **ì‘ì—… í‹°ì¼“ ë°œí–‰** | `tickets/` | `cof-task-context-management` | `create_ticket.py` ì‹¤í–‰ |
| **ì™„ë£Œ ì‘ì—… ì •ë¦¬** | `archive/` | `cof-task-context-management` | `archive_tasks.py` ì‹¤í–‰ |

> **Warning**: `mkdir`ë‚˜ `touch` ëª…ë ¹ì–´ë¡œ ìœ„ êµ¬ì¡°ë¥¼ ì§ì ‘ ìƒì„±í•˜ëŠ” ê²ƒì€ **ê¸ˆì§€**ëœë‹¤.

## 2. Node Definitions

### 2.1. Agents Task Context Node (`NN.agents-task-context/`)
- **ì—­í• **: ì—ì´ì „íŠ¸ì˜ ì‘ì—… ë§¥ë½(Context)ì„ ì €ì¥í•˜ê³  ì¶”ì í•œë‹¤.
- **ìœ„ì¹˜**: ì‘ì—… ëŒ€ìƒ ë””ë ‰í† ë¦¬ì˜ Sibling ìœ„ì¹˜
- **ê¶Œí•œ**:
  - ìƒì„±: `Using Skill` (O), `Manual` (X)
  - ìˆ˜ì •: `Using Skill` (O), `Manual` (X) - ë‹¨, ë‚´ìš©(Content) ìˆ˜ì •ì€ í—ˆìš©

## 3. Workflow Integration

ëª¨ë“  ì—ì´ì „íŠ¸ëŠ” ì‘ì—… ì‹œì‘ ì „ ë‹¤ìŒ ìˆœì„œë¥¼ ë”°ë¥¸ë‹¤:

1. **Check**: í˜„ì¬ ë””ë ‰í† ë¦¬ì— `NN.agents-task-context/`ê°€ ìˆëŠ”ê°€?
2. **If Missing**: `cof-task-context-management` ìŠ¤í‚¬ì„ ì‚¬ìš©í•˜ì—¬ ë…¸ë“œë¥¼ ìƒì„±í•œë‹¤. (ì‚¬ìš©ì ìŠ¹ì¸ í•„ìš”)
3. **If Present**: `tickets/`ì—ì„œ í• ë‹¹ëœ í‹°ì¼“ì„ í™•ì¸í•˜ê±°ë‚˜, ìƒˆë¡œìš´ í‹°ì¼“ì„ ë°œí–‰í•œë‹¤.

---
**Reference**:
- Doctrine: `core-docs/COF_DOCTRINE.md`
- Skill Manual: `skills/cof-task-context-management/SKILL.md`
#!/usr/bin/env python3
"""
Archive completed tasks.

Usage:
    python archive_tasks.py <node_path>
"""

import argparse
import sys
import shutil
from pathlib import Path
from datetime import datetime
import re

def get_ticket_status(content: str) -> str:
    """Extract status from frontmatter."""
    match = re.search(r"^status:\s*(\w+)", content, re.MULTILINE)
    if match:
        return match.group(1).lower()
    return "unknown"

def archive_tasks(node_path: str) -> bool:
    path = Path(node_path).resolve()
    tickets_dir = path / "tickets"
    archive_dir = path / "archive"
    archive_tickets_dir = archive_dir / "tickets"

    if not tickets_dir.exists():
        print(f"Error: tickets directory not found at {tickets_dir}", file=sys.stderr)
        return False

    # Ensure archive structure
    archive_tickets_dir.mkdir(parents=True, exist_ok=True)
    
    # Init archive README if not exists
    readme_path = archive_dir / "README.md"
    if not readme_path.exists():
        readme_path.write_text("# Archived Tasks\n\n| Date | Ticket | Status |\n|---|---|---|\n", encoding="utf-8")

    archived_count = 0
    
    for ticket_file in tickets_dir.glob("*.md"):
        content = ticket_file.read_text(encoding="utf-8")
        status = get_ticket_status(content)
        
        if status == "done":
            # Move to archive with collision handling
            dest = archive_tickets_dir / ticket_file.name
            if dest.exists():
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                new_name = f"{ticket_file.stem}_{timestamp}{ticket_file.suffix}"
                dest = archive_tickets_dir / new_name
                print(f"Collision detected. Renaming to: {new_name}")

            shutil.move(str(ticket_file), str(dest))
            
            # Log to README
            with open(readme_path, "a", encoding="utf-8") as f:
                date_str = datetime.now().strftime("%Y-%m-%d")
                f.write(f"| {date_str} | [{ticket_file.stem}](./tickets/{ticket_file.name}) | {status} |\n")
            
            print(f"Archived: {ticket_file.name}")
            archived_count += 1
            
    if archived_count == 0:
        print("No 'done' tickets found to archive.")
    else:
        print(f"Successfully archived {archived_count} tickets.")
        
    return True

def main():
    parser = argparse.ArgumentParser(description="Archive completed tickets.")
    parser.add_argument("path", help="Path to task-manager node")
    args = parser.parse_args()
    
    archive_tasks(args.path)

if __name__ == "__main__":
    main()
#!/usr/bin/env python3
"""
Validate COF Task Manager Node Health.

Checks:
1. Existence of RULE.md
2. Broken dependencies in tickets
"""

import argparse
import sys
import re
from pathlib import Path

def get_dependencies(content: str) -> list[str]:
    """Extract dependencies from frontmatter."""
    match = re.search(r"^dependencies:\s*\[(.*?)\]", content, re.MULTILINE)
    if match:
        deps_str = match.group(1)
        # Parse "Dep-1", "Dep-2"
        return [d.strip().strip('"\'') for d in deps_str.split(",") if d.strip()]
    return []

def validate_node(node_path: str) -> bool:
    path = Path(node_path).resolve()
    print(f"ğŸ” Validating Node: {path}")
    
    issues = []

    # 1. Essential Files
    if not (path / "RULE.md").exists():
        issues.append("[CRITICAL] Missing RULE.md")
    
    # 2. Tickets & Dependencies
    tickets_dir = path / "tickets"
    if tickets_dir.exists():
        ticket_files = {f.stem: f for f in tickets_dir.glob("*.md")}
        
        for name, file_path in ticket_files.items():
            content = file_path.read_text(encoding="utf-8")
            deps = get_dependencies(content)
            
            for dep in deps:
                if dep not in ticket_files:
                    issues.append(f"[ERROR] Ticket '{name}' has broken dependency: '{dep}' not found.")
    else:
        issues.append("[WARNING] 'tickets' directory missing.")

    # Report
    if issues:
        print("\nâŒ Validation Failed with Issues:")
        for issue in issues:
            print(f"  - {issue}")
        return False
    else:
        print("\nâœ… Node is Healthy.")
        return True

def main():
    parser = argparse.ArgumentParser(description="Validate COF node health.")
    parser.add_argument("path", help="Path to task-manager node")
    args = parser.parse_args()
    
    success = validate_node(args.path)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
